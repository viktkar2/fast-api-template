# Database Migrations

This project uses [Alembic](https://alembic.sqlalchemy.org/) for database schema management. Alembic tracks schema changes as versioned migration scripts and applies them in order against the target database.

## How It Works

1. SQLAlchemy ORM models are defined in `src/domain/models/entities/`
2. Alembic compares the models against the current database schema and generates a migration script with the diff
3. Each migration is a versioned Python file in `alembic/versions/` with `upgrade()` and `downgrade()` functions
4. Alembic tracks applied migrations in an `alembic_version` table in the database
5. Running `alembic upgrade head` applies all pending migrations

## Configuration

- **`alembic.ini`** — Alembic settings (script location, logging)
- **`alembic/env.py`** — Reads `DATABASE_URL` from the environment (falls back to `sqlite+aiosqlite:///./local.db` for local development). Uses the async engine to match the application's SQLAlchemy setup.

The database URL is **not** hardcoded in `alembic.ini`. It is set dynamically in `env.py` from the `DATABASE_URL` environment variable, so the same configuration works across local dev, CI, and production.

## Common Commands

```bash
# Apply all pending migrations
uv run alembic upgrade head

# Generate a new migration after changing a model
uv run alembic revision --autogenerate -m "describe the change"

# Show current migration revision
uv run alembic current

# Show migration history
uv run alembic history

# Downgrade by one revision
uv run alembic downgrade -1

# Downgrade to a specific revision
uv run alembic downgrade <revision_id>

# Generate SQL without applying (offline mode)
uv run alembic upgrade head --sql
```

## Workflow

### Making a Schema Change

1. Modify the SQLAlchemy model in `src/domain/models/entities/`
2. Generate a migration:
   ```bash
   uv run alembic revision --autogenerate -m "add email_verified to users"
   ```
3. **Review the generated migration** in `alembic/versions/` — autogenerate is good but not perfect (it can miss things like renamed columns, enum value changes, or data migrations)
4. Apply locally:
   ```bash
   uv run alembic upgrade head
   ```
5. Commit the migration file alongside the model change

### Adding a New Model

1. Create the model in `src/domain/models/entities/`
2. Import it in `src/domain/models/entities/__init__.py` so `Base.metadata` registers it
3. Follow the same generate/review/apply steps above

## Production Deployment

Migrations should run **before** the application starts serving traffic. The recommended approach is to run them in the Docker entrypoint:

```dockerfile
CMD ["sh", "-c", "alembic upgrade head && uvicorn src.app:app --host 0.0.0.0 --port 8000"]
```

This ensures:
- Tables exist before the first request
- New columns/indexes are applied on each deploy
- If a migration fails, the container fails to start (no partial state)

Set the `DATABASE_URL` environment variable on your Azure resource to point at your database:

```
# PostgreSQL (Azure Flexible Server)
DATABASE_URL=postgresql+asyncpg://user:password@host:5432/dbname

# Azure SQL
DATABASE_URL=mssql+aioodbc://user:password@host/dbname?driver=ODBC+Driver+18+for+SQL+Server
```

## Things to Know

- **Always review autogenerated migrations.** Alembic cannot detect: column renames (it sees a drop + add), changes to enum values, or data migrations. Write these by hand.
- **Never edit a migration that has already been applied** to a shared environment. Create a new migration instead.
- **Migration files are source-controlled.** They should be committed and reviewed like any other code change.
- **The local SQLite database** (`local.db`) is gitignored and disposable. To reset it, delete the file and run `uv run alembic upgrade head`.
